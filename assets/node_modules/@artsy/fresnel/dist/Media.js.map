{"version":3,"sources":["../src/Media.tsx"],"names":["createMedia","config","breakpoints","mediaQueries","MediaQueries","interactions","DynamicResponsive","MediaContext","React","createContext","displayName","MediaParentContext","hasParentMedia","breakpointProps","getMediaContextValue","onlyMatch","MediaContextProvider","disableDynamicMediaQueries","children","MediaContextValue","dynamicResponsiveMediaQueries","mediaQueryTypes","matches","matchingMediaQueries","Object","keys","filter","key","Media","props","validateProps","passedClassName","className","style","interaction","mediaParentContextValue","getMediaParentContextValue","mediaParentContext","at","largestBreakpoint","ownerName","owner","_reactInternalFiber","_debugOwner","type","name","err","console","warn","breakpoint","doesMatchParent","toVisibleAtBreakpointSet","length","renderChildren","undefined","shouldRenderMediaQuery","Function","Component","createMediaStyle","toStyle","SortedBreakpoints","sortedBreakpoints","findBreakpointAtWidth","findBreakpointsForWidths","valuesWithBreakpointProps","MutuallyExclusiveProps","validKeys","selectedProps","prop","includes","Error","join"],"mappings":"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","sourcesContent":["// tslint:disable:jsdoc-format\n\nimport React, { CSSProperties } from \"react\"\nimport { createResponsiveComponents } from \"./DynamicResponsive\"\nimport { MediaQueries } from \"./MediaQueries\"\nimport {\n  intersection,\n  propKey,\n  createClassName,\n  castBreakpointsToIntegers,\n  memoize,\n} from \"./Utils\"\nimport { BreakpointConstraint } from \"./Breakpoints\"\n\n/**\n * A render prop that can be used to render a different container element than\n * the default `div`.\n *\n * @see {@link MediaProps.children}.\n */\nexport type RenderProp = (\n  className: string,\n  renderChildren: boolean\n) => React.ReactNode\n\n// TODO: All of these props should be mutually exclusive. Using a union should\n//       probably be made possible by https://github.com/Microsoft/TypeScript/pull/27408.\nexport interface MediaBreakpointProps<BreakpointKey = string> {\n  /**\n   * Children will only be shown if the viewport matches the specified\n   * breakpoint. That is, a viewport width that’s higher than the configured\n   * breakpoint value, but lower than the value of the next breakpoint, if any\n   * larger breakpoints exist at all.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width between 0 and 768\n     <Media at=\"xs\">ohai</Media>\n\n     // Matches a viewport that has a width between 768 and 1024\n     <Media at=\"sm\">ohai</Media>\n\n     // Matches a viewport that has a width over 1024\n     <Media at=\"md\">ohai</Media>\n     ```\n   *\n   */\n  at?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is smaller than the specified\n   * breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n    // Matches a viewport that has a width from 0 to 767\n     <Media lessThan=\"sm\">ohai</Media>\n\n     // Matches a viewport that has a width from 0 to 1023\n     <Media lessThan=\"md\">ohai</Media>\n     ```\n   *\n   */\n  lessThan?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is greater than the specified\n   * breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width from 768 to infinity\n     <Media greaterThan=\"xs\">ohai</Media>\n\n     // Matches a viewport that has a width from 1024 to infinity\n     <Media greaterThan=\"sm\">ohai</Media>\n     ```\n   *\n   */\n  greaterThan?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is greater or equal to the\n   * specified breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width from 0 to infinity\n     <Media greaterThanOrEqual=\"xs\">ohai</Media>\n\n     // Matches a viewport that has a width from 768 to infinity\n     <Media greaterThanOrEqual=\"sm\">ohai</Media>\n\n     // Matches a viewport that has a width from 1024 to infinity\n     <Media greaterThanOrEqual=\"md\">ohai</Media>\n     ```\n   *\n   */\n  greaterThanOrEqual?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is between the specified\n   * breakpoints. That is, a viewport width that’s higher than or equal to the\n   * small breakpoint value, but lower than the value of the large breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width from 0 to 767\n     <Media between={[\"xs\", \"sm\"]}>ohai</Media>\n\n     // Matches a viewport that has a width from 0 to 1023\n     <Media between={[\"xs\", \"md\"]}>ohai</Media>\n     ```\n   *\n   */\n  between?: [BreakpointKey, BreakpointKey]\n}\n\nexport interface MediaProps<BreakpointKey, Interaction>\n  extends MediaBreakpointProps<BreakpointKey> {\n  /**\n   * Children will only be shown if the interaction query matches.\n   *\n   * @example\n\n     ```tsx\n     // With interactions defined like these\n     { hover: \"(hover: hover)\" }\n\n     // Matches an input device that is capable of hovering\n     <Media interaction=\"hover\">ohai</Media>\n     ```\n   */\n  interaction?: Interaction\n\n  /**\n   * The component(s) that should conditionally be shown, depending on the media\n   * query matching.\n   *\n   * In case a different element is preferred, a render prop can be provided\n   * that receives the class-name it should use to have the media query styling\n   * applied.\n   *\n   * Additionally, the render prop receives a boolean that indicates wether or\n   * not its children should be rendered, which will be `false` if the media\n   * query is not included in the `onlyMatch` list. Use this flag if your\n   * component’s children may be expensive to render and you want to avoid any\n   * unnecessary work.\n   * (@see {@link MediaContextProviderProps.onlyMatch} for details)\n   *\n   * @example\n   *\n     ```tsx\n     const Component = () => (\n       <Media greaterThan=\"xs\">\n         {(className, renderChildren) => (\n           <span className={className}>\n             {renderChildren && \"ohai\"}\n           </span>\n         )}\n       </Media>\n     )\n     ```\n   *\n   */\n  children: React.ReactNode | RenderProp\n\n  /**\n   * Additional classNames to passed down and applied to Media container\n   */\n  className?: string\n\n  /**\n   * Additional styles to passed down and applied to Media container\n   */\n  style?: CSSProperties\n}\n\nexport interface MediaContextProviderProps<M> {\n  /**\n   * This list of breakpoints and interactions can be used to limit the rendered\n   * output to these.\n   *\n   * For instance, when a server knows for some user-agents that certain\n   * breakpoints will never apply, omitting them altogether will lower the\n   * rendered byte size.\n   */\n  onlyMatch?: M[]\n\n  /**\n   * Disables usage of browser MediaQuery API to only render at the current\n   * breakpoint.\n   *\n   * Use this with caution, as disabling this means React components for all\n   * breakpoints will be mounted client-side and all associated life-cycle hooks\n   * will be triggered, which could lead to unintended side-effects.\n   */\n  disableDynamicMediaQueries?: boolean\n}\n\nexport interface CreateMediaConfig {\n  /**\n   * The breakpoint definitions for your application. Width definitions should\n   * start at 0.\n   *\n   * @see {@link createMedia}\n   */\n  breakpoints: { [key: string]: number | string }\n\n  /**\n   * The interaction definitions for your application.\n   */\n  interactions?: { [key: string]: string }\n}\n\nexport interface CreateMediaResults<BreakpointKey, Interactions> {\n  /**\n   * The React component that you use throughout your application.\n   *\n   * @see {@link MediaBreakpointProps}\n   */\n  Media: React.ComponentType<MediaProps<BreakpointKey, Interactions>>\n\n  /**\n   * The React Context provider component that you use to constrain rendering of\n   * breakpoints to a set list and to enable client-side dynamic constraining.\n   *\n   * @see {@link MediaContextProviderProps}\n   */\n  MediaContextProvider: React.ComponentType<\n    MediaContextProviderProps<BreakpointKey | Interactions> & {\n      children: React.ReactNode\n    }\n  >\n\n  /**\n   * Generates a set of CSS rules that you should include in your application’s\n   * styling to enable the hiding behaviour of your `Media` component uses.\n   */\n  createMediaStyle(breakpointKeys?: BreakpointConstraint[]): string\n\n  /**\n   * A list of your application’s breakpoints sorted from small to large.\n   */\n  SortedBreakpoints: BreakpointKey[]\n\n  /**\n   * Creates a list of your application’s breakpoints that support the given\n   * widths and everything in between.\n   */\n  findBreakpointsForWidths(\n    fromWidth: number,\n    throughWidth: number\n  ): BreakpointKey[] | undefined\n\n  /**\n   * Finds the breakpoint that matches the given width.\n   */\n  findBreakpointAtWidth(width: number): BreakpointKey | undefined\n\n  /**\n   * Maps a list of values for various breakpoints to props that can be used\n   * with the `Media` component.\n   *\n   * The values map to corresponding indices in the sorted breakpoints array. If\n   * less values are specified than the number of breakpoints your application\n   * has, the last value will be applied to all subsequent breakpoints.\n   */\n  valuesWithBreakpointProps<SizeValue>(\n    values: SizeValue[]\n  ): [SizeValue, MediaBreakpointProps<BreakpointKey>][]\n}\n\n/**\n * This is used to generate a Media component, its context provider, and CSS\n * rules based on your application’s breakpoints and interactions.\n *\n * Note that the interaction queries are entirely up to you to define and they\n * should be written in such a way that they match when you want the element to\n * be hidden.\n *\n * @example\n *\n   ```tsx\n   const MyAppMedia = createMedia({\n     breakpoints: {\n       xs: 0,\n       sm: 768,\n       md: 900\n       lg: 1024,\n       xl: 1192,\n     },\n     interactions: {\n       hover: `not all and (hover:hover)`\n     },\n   })\n\n   export const Media = MyAppMedia.Media\n   export const MediaContextProvider = MyAppMedia.MediaContextProvider\n   export const createMediaStyle = MyAppMedia.createMediaStyle\n   ```\n *\n */\nexport function createMedia<\n  MediaConfig extends CreateMediaConfig,\n  BreakpointKey extends keyof MediaConfig[\"breakpoints\"],\n  Interaction extends keyof MediaConfig[\"interactions\"]\n>(config: MediaConfig): CreateMediaResults<BreakpointKey, Interaction> {\n  const breakpoints = castBreakpointsToIntegers(config.breakpoints)\n\n  const mediaQueries = new MediaQueries<BreakpointKey>(\n    breakpoints,\n    config.interactions || {}\n  )\n\n  const DynamicResponsive = createResponsiveComponents()\n\n  const MediaContext = React.createContext<\n    MediaContextProviderProps<BreakpointKey | Interaction>\n  >({})\n  MediaContext.displayName = \"Media.Context\"\n\n  const MediaParentContext = React.createContext<{\n    hasParentMedia: boolean\n    breakpointProps: MediaBreakpointProps<BreakpointKey>\n  }>({ hasParentMedia: false, breakpointProps: {} })\n  MediaContext.displayName = \"MediaParent.Context\"\n\n  const getMediaContextValue = memoize(onlyMatch => ({\n    onlyMatch,\n  }))\n\n  const MediaContextProvider: React.FunctionComponent<\n    MediaContextProviderProps<BreakpointKey | Interaction> & {\n      children?: React.ReactNode\n    }\n  > = ({ disableDynamicMediaQueries, onlyMatch, children }) => {\n    if (disableDynamicMediaQueries) {\n      const MediaContextValue = getMediaContextValue(onlyMatch)\n\n      return (\n        <MediaContext.Provider value={MediaContextValue}>\n          {children}\n        </MediaContext.Provider>\n      )\n    } else {\n      return (\n        <DynamicResponsive.Provider\n          mediaQueries={mediaQueries.dynamicResponsiveMediaQueries}\n          initialMatchingMediaQueries={intersection(\n            mediaQueries.mediaQueryTypes,\n            onlyMatch\n          )}\n        >\n          <DynamicResponsive.Consumer>\n            {matches => {\n              const matchingMediaQueries = Object.keys(matches).filter(\n                key => matches[key]\n              )\n\n              const MediaContextValue = getMediaContextValue(\n                intersection(matchingMediaQueries, onlyMatch)\n              )\n\n              return (\n                <MediaContext.Provider value={MediaContextValue}>\n                  {children}\n                </MediaContext.Provider>\n              )\n            }}\n          </DynamicResponsive.Consumer>\n        </DynamicResponsive.Provider>\n      )\n    }\n  }\n\n  const Media = class extends React.Component<\n    MediaProps<BreakpointKey, Interaction>\n  > {\n    constructor(props) {\n      super(props)\n      validateProps(props)\n    }\n\n    static defaultProps = {\n      className: \"\",\n      style: {},\n    }\n\n    static contextType = MediaParentContext\n\n    getMediaParentContextValue = memoize(\n      (breakpointProps: MediaBreakpointProps<BreakpointKey>) => ({\n        hasParentMedia: true,\n        breakpointProps,\n      })\n    )\n\n    render() {\n      const props = this.props\n      const {\n        children,\n        className: passedClassName,\n        style,\n        interaction,\n        ...breakpointProps\n      } = props\n      const mediaParentContextValue = this.getMediaParentContextValue(\n        breakpointProps\n      )\n\n      return (\n        <MediaParentContext.Consumer>\n          {mediaParentContext => {\n            return (\n              <MediaParentContext.Provider value={mediaParentContextValue}>\n                <MediaContext.Consumer>\n                  {({ onlyMatch } = {}) => {\n                    let className: string | null\n                    if (props.interaction) {\n                      className = createClassName(\n                        \"interaction\",\n                        props.interaction\n                      )\n                    } else {\n                      if (props.at) {\n                        const largestBreakpoint =\n                          mediaQueries.breakpoints.largestBreakpoint\n                        if (props.at === largestBreakpoint) {\n                          // TODO: We should look into making React’s __DEV__ available\n                          //       and have webpack completely compile these away.\n                          let ownerName = null\n                          try {\n                            const owner = (this as any)._reactInternalFiber\n                              ._debugOwner.type\n                            ownerName = owner.displayName || owner.name\n                          } catch (err) {\n                            // no-op\n                          }\n\n                          console.warn(\n                            \"[@artsy/fresnel] \" +\n                              \"`at` is being used with the largest breakpoint. \" +\n                              \"Consider using `<Media greaterThanOrEqual=\" +\n                              `\"${largestBreakpoint}\">\\` to account for future ` +\n                              `breakpoint definitions outside of this range.${\n                                ownerName\n                                  ? ` It is being used in the ${ownerName} component.`\n                                  : \"\"\n                              }`\n                          )\n                        }\n                      }\n\n                      const type = propKey(breakpointProps)\n                      const breakpoint = breakpointProps[type]!\n                      className = createClassName(type, breakpoint)\n                    }\n\n                    const doesMatchParent =\n                      !mediaParentContext.hasParentMedia ||\n                      intersection(\n                        mediaQueries.breakpoints.toVisibleAtBreakpointSet(\n                          mediaParentContext.breakpointProps\n                        ),\n                        mediaQueries.breakpoints.toVisibleAtBreakpointSet(\n                          breakpointProps\n                        )\n                      ).length > 0\n                    const renderChildren =\n                      doesMatchParent &&\n                      (onlyMatch === undefined ||\n                        mediaQueries.shouldRenderMediaQuery(\n                          { ...breakpointProps, interaction },\n                          onlyMatch\n                        ))\n\n                    if (props.children instanceof Function) {\n                      return props.children(className, renderChildren)\n                    } else {\n                      return (\n                        <div\n                          className={`fresnel-container ${className} ${passedClassName}`}\n                          style={style}\n                          suppressHydrationWarning={!renderChildren}\n                        >\n                          {renderChildren ? props.children : null}\n                        </div>\n                      )\n                    }\n                  }}\n                </MediaContext.Consumer>\n              </MediaParentContext.Provider>\n            )\n          }}\n        </MediaParentContext.Consumer>\n      )\n    }\n  }\n\n  return {\n    Media,\n    MediaContextProvider,\n    createMediaStyle: mediaQueries.toStyle,\n    SortedBreakpoints: [...mediaQueries.breakpoints.sortedBreakpoints],\n    findBreakpointAtWidth: mediaQueries.breakpoints.findBreakpointAtWidth,\n    findBreakpointsForWidths: mediaQueries.breakpoints.findBreakpointsForWidths,\n    valuesWithBreakpointProps:\n      mediaQueries.breakpoints.valuesWithBreakpointProps,\n  }\n}\n\nconst MutuallyExclusiveProps: string[] = MediaQueries.validKeys()\n\nfunction validateProps(props) {\n  const selectedProps = Object.keys(props).filter(prop =>\n    MutuallyExclusiveProps.includes(prop)\n  )\n  if (selectedProps.length < 1) {\n    throw new Error(`1 of ${MutuallyExclusiveProps.join(\", \")} is required.`)\n  } else if (selectedProps.length > 1) {\n    throw new Error(\n      `Only 1 of ${selectedProps.join(\", \")} is allowed at a time.`\n    )\n  }\n}\n"],"file":"Media.js"}